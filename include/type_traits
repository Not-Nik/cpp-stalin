// cpp-stalin (c) Nikolas Wipper 2021

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

#ifndef CPP_STALIN_INCLUDE_TYPETRAITS_H_
#define CPP_STALIN_INCLUDE_TYPETRAITS_H_

#include "cstddef"
#include "cstdint"
#include "cstring"
#include "__config"
#include "__declval"

namespace std {

// Helper Classes

template <class T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type = integral_constant; // using injected-class-name
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; } // since c++14
};

template <bool B> using bool_constant = integral_constant<bool, B>;
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

template <class T, class U>
struct is_same : false_type {};

template <class T>
struct is_same<T, T> : true_type {};

template <class T>
struct remove_cv { typedef T type; };
template <class T>
struct remove_cv<const T> { typedef T type; };
template <class T>
struct remove_cv<volatile T> { typedef T type; };
template <class T>
struct remove_cv<const volatile T> { typedef T type; };

template <class T>
struct remove_const { typedef T type; };
template <class T>
struct remove_const<const T> { typedef T type; };

template <class T>
struct remove_volatile { typedef T type; };
template <class T>
struct remove_volatile<volatile T> { typedef T type; };

template <class T> using remove_const_t = typename remove_const<T>::type;
template <class T> using remove_volatile_t = typename remove_volatile<T>::type;
template <class T> using remove_cv_t = typename remove_cv<T>::type;

template <class T>
struct is_void : is_same<void, typename remove_cv<T>::type> {};

template <class T>
struct is_null_pointer : is_same<nullptr_t, remove_cv_t<T>> {};

template <class T>
struct is_integral : bool_constant<is_same<bool, typename remove_cv<T>::type>::value || is_same<char, typename remove_cv<T>::type>::value
                                       || is_same<char16_t, typename remove_cv<T>::type>::value
                                       || is_same<char32_t, typename remove_cv<T>::type>::value
                                       || is_same<wchar_t, typename remove_cv<T>::type>::value || is_same<short, typename remove_cv<T>::type>::value
                                       || is_same<int, typename remove_cv<T>::type>::value || is_same<long, typename remove_cv<T>::type>::value
                                       || is_same<long long, typename remove_cv<T>::type>::value> {
};

template <class T>
struct is_floating_point : bool_constant<is_same<float, typename remove_cv<T>::type>::value || is_same<double, typename remove_cv<T>::type>::value
                                             || is_same<long double, typename remove_cv<T>::type>::value> {
};

template <class T>
struct is_array : false_type {};
template <class T>
struct is_array<T[]> : true_type {};
template <class T, size_t N>
struct is_array<T[N]> : true_type {};

template <class T>
struct __tt_is_union : public false_type {};

template <class T>
struct is_union : public __tt_is_union<typename remove_cv<T>::type> {};

struct __two { char __lx[2]; };

namespace __is_class_imp {
template <class T>
char __test(int T::*);
template <class T>
__two __test(...);
}

template <class T>
struct is_class : public integral_constant<bool, sizeof(__is_class_imp::__test<T>(0)) == 1 && !is_union<T>::value> {};

// primary template
template <class>
struct is_function : false_type {};

// specialization for regular functions
template <class Ret, class... Args>
struct is_function<Ret(Args...)> : true_type {};

// specialization for variadic functions such as printf
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...)> : true_type {};

// specialization for function types that have cv-qualifiers
template <class Ret, class... Args>
struct is_function<Ret(Args...) const> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) volatile> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const volatile> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) volatile> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const volatile> : true_type {};

// specialization for function types that have ref-qualifiers
template <class Ret, class... Args>
struct is_function<Ret(Args...) &> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const &> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) volatile &> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const volatile &> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) &> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const &> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) volatile &> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const volatile &> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) &&> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const &&> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) volatile &&> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const volatile &&> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) &&> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const &&> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) volatile &&> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const volatile &&> : true_type {};

// specializations for noexcept versions of all the above (C++17 and later)

template <class Ret, class... Args>
struct is_function<Ret(Args...) noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) volatile noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const volatile noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) volatile noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const volatile noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) &noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const &noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) volatile &noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const volatile &noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) &noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const &noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) volatile &noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const volatile &noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) &&noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const &&noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) volatile &&noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args...) const volatile &&noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) &&noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const &&noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) volatile &&noexcept> : true_type {};
template <class Ret, class... Args>
struct is_function<Ret(Args..., ...) const volatile &&noexcept> : true_type {};

template <class T>
struct is_pointer_helper : false_type {};
template <class T>
struct is_pointer_helper<T *> : true_type {};

template <class T>
struct is_pointer : is_pointer_helper<typename remove_cv<T>::type> {};

template <class T>
struct is_lvalue_reference : false_type {};
template <class T>
struct is_lvalue_reference<T &> : true_type {};

template <class T>
struct is_rvalue_reference : false_type {};
template <class T>
struct is_rvalue_reference<T &&> : true_type {};

template <class T>
struct is_member_pointer_helper : false_type {};

template <class T, class U>
struct is_member_pointer_helper<T U::*> : true_type {};

template <class T>
struct is_member_pointer : is_member_pointer_helper<typename remove_cv<T>::type> {};

template <class T>
struct is_member_function_pointer_helper : false_type {};

template <class T, class U>
struct is_member_function_pointer_helper<T U::*> : is_function<T> {};

template <class T>
struct is_member_function_pointer : is_member_function_pointer_helper<typename remove_cv<T>::type> {};

template <class T>
struct is_member_object_pointer : integral_constant<bool, is_member_pointer<T>::value && !is_member_function_pointer<T>::value> {};

template <class T>
struct is_arithmetic : integral_constant<bool, is_integral<T>::value || is_floating_point<T>::value> {};

template <class T>
struct is_fundamental : integral_constant<bool,
                                               is_arithmetic<T>::value || is_void<T>::value
                                                   || is_same<nullptr_t, typename remove_cv<T>::type>::value> {
};

template <class T>
struct is_compound : integral_constant<bool, !is_fundamental<T>::value> {};

template <class T>
struct is_reference : false_type {};
template <class T>
struct is_reference<T &> : true_type {};
template <class T>
struct is_reference<T &&> : true_type {};

template <class T>
struct is_enum : public integral_constant<bool,
                                          !is_void<T>::value && !is_integral<T>::value && !is_floating_point<T>::value && !is_array<T>::value
                                              && !is_pointer<T>::value && !is_reference<T>::value && !is_member_pointer<T>::value
                                              && !is_union<T>::value && !is_class<T>::value && !is_function<T>::value> {
};

template <class T>
struct is_scalar : integral_constant<bool,
                                          is_arithmetic<T>::value || is_enum<T>::value || is_pointer<T>::value
                                              || is_member_pointer<T>::value || is_null_pointer<T>::value> {
};

template <class T>
struct is_const : false_type {};
template <class T>
struct is_const<const T> : true_type {};

template <class T>
struct is_volatile : false_type {};
template <class T>
struct is_volatile<volatile T> : true_type {};

template <class T>
struct remove_reference { typedef T type; };
template <class T>
struct remove_reference<T &> { typedef T type; };
template <class T>
struct remove_reference<T &&> { typedef T type; };

#ifdef STALIN_CXX_STD_SINCE_14
template< class T >
using remove_reference_t = typename remove_reference<T>::type;
#endif

template <class T>
struct remove_all_extents { typedef T type; };

template <class T>
struct remove_all_extents<T[]> {
    typedef typename remove_all_extents<T>::type type;
};

template <class T, size_t N>
struct remove_all_extents<T[N]> {
    typedef typename remove_all_extents<T>::type type;
};

template <bool B, class T = void>
struct enable_if {};

template <class T>
struct enable_if<true, T> { typedef T type; };

template <class T>
struct is_trivially_copyable : integral_constant<bool, is_scalar<typename remove_all_extents<T>::type>::value> {};

template <class T>
struct is_standard_layout : integral_constant<bool, is_scalar<typename remove_all_extents<T>::type>::value> {};

namespace detail {
template <typename T, bool = is_arithmetic<T>::value>
struct is_signed : integral_constant<bool, T(-1) < T(0)> {};

template <typename T>
struct is_signed<T, false> : false_type {};
} // namespace detail

template <typename T>
struct is_signed : detail::is_signed<T>::type {};

namespace detail {
template <typename T, bool = is_arithmetic<T>::value>
struct is_unsigned : integral_constant<bool, T(0) < T(-1)> {};

template <typename T>
struct is_unsigned<T, false> : false_type {};
} // namespace detail

template <typename T>
struct is_unsigned : detail::is_unsigned<T>::type {};

template <typename T, typename AT_1 = void, typename AT_2 = void, typename AT_3 = void, typename AT_4 = void>
class is_constructible_impl {
private:
    template <typename C_T, typename C_AT_1, typename C_AT_2, typename C_AT_3, typename C_AT_4>
    static bool test(typename enable_if<sizeof(C_T)
                                                 == sizeof(C_T(static_cast< C_AT_1 >( *static_cast< typename remove_reference<C_AT_1>::type * >( NULL )),
                                                               static_cast< C_AT_2 >( *static_cast< typename remove_reference<C_AT_2>::type * >( NULL )),
                                                               static_cast< C_AT_3 >( *static_cast< typename remove_reference<C_AT_3>::type * >( NULL )),
                                                               static_cast< C_AT_4 >( *static_cast< typename remove_reference<C_AT_4>::type * >( NULL ))))>::type *);

    template <typename, typename, typename, typename, typename>
    static int test(...);

public:
    static const bool value = (sizeof(test<T, AT_1, AT_2, AT_3, AT_4>(NULL)) == sizeof(bool));
};

template <typename T, typename AT_1, typename AT_2, typename AT_3>
class is_constructible_impl<T, AT_1, AT_2, AT_3, void> {
private:
    template <typename C_T, typename C_AT_1, typename C_AT_2, typename C_AT_3>
    static bool test(typename enable_if<sizeof(C_T)
                                                 == sizeof(C_T(static_cast< C_AT_1 >( *static_cast< typename remove_reference<C_AT_1>::type * >( NULL )),
                                                               static_cast< C_AT_2 >( *static_cast< typename remove_reference<C_AT_2>::type * >( NULL )),
                                                               static_cast< C_AT_3 >( *static_cast< typename remove_reference<C_AT_3>::type * >( NULL ))))>::type *);

    template <typename, typename, typename, typename>
    static int test(...);

public:
    static const bool value = (sizeof(test<T, AT_1, AT_2, AT_3>(NULL)) == sizeof(bool));
};

template <typename T, typename AT_1, typename AT_2>
class is_constructible_impl<T, AT_1, AT_2, void, void> {
private:

    template <typename C_T, typename C_AT_1, typename C_AT_2>
    static bool test(typename enable_if<sizeof(C_T)
                                                 == sizeof(C_T(static_cast< C_AT_1 >( *static_cast< typename remove_reference<C_AT_1>::type * >( NULL )),
                                                               static_cast< C_AT_2 >( *static_cast< typename remove_reference<C_AT_2>::type * >( NULL ))))>::type *);

    template <typename, typename, typename>
    static int test(...);

public:
    static const bool value = (sizeof(test<T, AT_1, AT_2>(NULL)) == sizeof(bool));
};

template <typename T, typename AT_1>
class is_constructible_impl<T, AT_1, void, void, void> {
private:
    template <typename C_T, typename C_AT_1>
    static bool test(typename enable_if<
        sizeof(C_T) == sizeof(C_T(static_cast< C_AT_1 >( *static_cast< typename remove_reference<C_AT_1>::type * >( NULL ))))>::type *);

    template <typename, typename>
    static int test(...);

public:
    static const bool value = (sizeof(test<T, AT_1>(NULL)) == sizeof(bool));
};

template <typename T>
class is_constructible_impl<T, void, void, void, void> {
private:
    template <typename C_T>
    static C_T testFun(C_T);

    template <typename C_T>
    static bool test(typename enable_if<sizeof(C_T) == sizeof(testFun(C_T()))>::type *);

    template <typename>
    static int test(...);

public:
    static const bool value = (sizeof(test<T>(NULL)) == sizeof(bool));
};

template <typename T, typename AT_1 = void, typename AT_2 = void, typename AT_3 = void, typename AT_4 = void>
class is_constructible_impl_ptr {
public:
    static const bool value = false;
};

template <typename T, typename AT_1>
class is_constructible_impl_ptr<T, AT_1, typename enable_if<is_pointer<typename remove_reference<T>::type>::value, void>::type, void, void> {
private:
    template <typename C_T>
    static bool test(C_T);

    template <typename>
    static int test(...);

public:
    static const bool value = (sizeof(test<T>(static_cast< AT_1 >( NULL ))) == sizeof(bool));
};

template <typename T>
class is_constructible_impl_ptr<T, void, void, void, void> {
public:
    static const bool value = true;
};

template <typename T, typename AT_1 = void, typename AT_2 = void, typename AT_3 = void, typename AT_4 = void>
class is_constructible {
public:
    static const bool value = (is_pointer<typename remove_reference<T>::type>::value ? is_constructible_impl_ptr<T, AT_1, AT_2, AT_3, AT_4>::value
                                                                                     : is_constructible_impl<T, AT_1, AT_2, AT_3, AT_4>::value);
};

namespace detail {

template <class T>
struct type_identity { using type = T; }; // or use type_identity (since C++20)

template <class T>
auto try_add_lvalue_reference(int) -> type_identity<T &>;
template <class T>
auto try_add_lvalue_reference(...) -> type_identity<T>;

template <class T>
auto try_add_rvalue_reference(int) -> type_identity<T &&>;
template <class T>
auto try_add_rvalue_reference(...) -> type_identity<T>;
} // namespace detail

template <class T>
struct add_lvalue_reference : decltype(detail::try_add_lvalue_reference<T>(0)) {};

template <class T>
struct add_rvalue_reference : decltype(detail::try_add_rvalue_reference<T>(0)) {};

template <class T, class... Args>
struct is_trivially_constructible : false_type {
};

template <class T>
struct is_trivially_constructible<T> : integral_constant<bool, is_scalar<T>::value> {
};

template <class T>
struct is_trivially_constructible<T, T &&> : integral_constant<bool, is_scalar<T>::value> {
};

template <class T>
struct is_trivially_constructible<T, const T &> : integral_constant<bool, is_scalar<T>::value> {
};

template <class T>
struct is_trivially_constructible<T, T &> : integral_constant<bool, is_scalar<T>::value> {
};

template <bool, bool, class T, class... Args>
struct __stalin_is_nothrow_constructible;

template <class T, class... Args>
struct __stalin_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, T, Args...> : public integral_constant<bool,
                                                                                                                                 noexcept(T(declval<
                                                                                                                                     Args>()...))> {
};

template <class T>
void __implicit_conversion_to(T) noexcept {}

template <class T, class Arg>
struct __stalin_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, T, Arg> : public integral_constant<bool,
                                                                                                                            noexcept(__implicit_conversion_to<
                                                                                                                                T>(declval<Arg>()))> {
};

template <class T, bool _IsReference, class... Args>
struct __stalin_is_nothrow_constructible</*is constructible*/false, _IsReference, T, Args...> : public false_type {
};

template <class T, class... Args>
struct is_nothrow_constructible : __stalin_is_nothrow_constructible<is_constructible<T, Args...>::value, is_reference<T>::value, T, Args...> {
};

template <class T, size_t Ns>
struct is_nothrow_constructible<T[Ns]> : __stalin_is_nothrow_constructible<is_constructible<T>::value, is_reference<T>::value, T> {
};

template <class T>
struct is_move_constructible : is_constructible<T, typename add_rvalue_reference<T>::type> {};

template <class T>
struct is_trivially_move_constructible : is_trivially_constructible<T, typename add_rvalue_reference<T>::type> {};

template <class T>
struct is_nothrow_move_constructible : is_nothrow_constructible<T, typename add_rvalue_reference<T>::type> {};

template <typename, typename T>
struct __select_2nd { typedef T type; };

template <class T, class Arg>
typename __select_2nd<decltype((declval<T>() = declval<Arg>())), true_type>::type __is_assignable_test(int);

template <class, class>
false_type __is_assignable_test(...);

template <class T, class Arg, bool = is_void<T>::value || is_void<Arg>::value>
struct __is_assignable_imp : public decltype((__is_assignable_test<T, Arg>(0))) {};

template <class T, class Arg>
struct __is_assignable_imp<T, Arg, true> : public false_type {
};

template <class T, class Arg>
struct is_assignable : public __is_assignable_imp<T, Arg> {};

template <class T, class Arg>
struct is_trivially_assignable : public false_type {};

template <class T>
struct is_trivially_assignable<T &, T> : integral_constant<bool, is_scalar<T>::value> {};

template <class T>
struct is_trivially_assignable<T &, T &> : integral_constant<bool, is_scalar<T>::value> {};

template <class T>
struct is_trivially_assignable<T &, const T &> : integral_constant<bool, is_scalar<T>::value> {};

template <class T>
struct is_trivially_assignable<T &, T &&> : integral_constant<bool, is_scalar<T>::value> {};

template <bool, class T, class Arg>
struct __stalin_is_nothrow_assignable;

template <class T, class Arg>
struct __stalin_is_nothrow_assignable<false, T, Arg> : public false_type {
};

template <class T, class Arg>
struct __stalin_is_nothrow_assignable<true, T, Arg> : public integral_constant<bool, noexcept(declval<T>() = declval<Arg>())> {
};

template <class T, class Arg>
struct is_nothrow_assignable : public __stalin_is_nothrow_assignable<is_assignable<T, Arg>::value, T, Arg> {
};

template <class T>
struct is_move_assignable : is_assignable<typename add_lvalue_reference<T>::type, typename add_rvalue_reference<T>::type> {};

template <class T>
struct is_trivially_move_assignable : is_trivially_assignable<typename add_lvalue_reference<T>::type,
                                                                   typename add_rvalue_reference<T>::type> {
};

template <class T>
struct is_nothrow_move_assignable : is_nothrow_assignable<typename add_lvalue_reference<T>::type,
                                                               typename add_rvalue_reference<T>::type> {
};

namespace details {
template <typename B>
true_type test_pre_ptr_convertible(const volatile B *);
template <typename>
false_type test_pre_ptr_convertible(const volatile void *);

template <typename, typename>
auto test_pre_is_base_of(...) -> true_type;
template <typename B, typename D>
auto test_pre_is_base_of(int) -> decltype(test_pre_ptr_convertible<B>(static_cast<D *>(nullptr)));
}

template <typename Base, typename Derived>
struct is_base_of : integral_constant<bool,
                                           is_class<Base>::value && is_class<Derived>::value
                                               && decltype(details::test_pre_is_base_of<Base, Derived>(0))::value> {
};

template <class T>
typename remove_reference<T>::type &&move(T &&arg) noexcept {
    return arg;
}
}

#endif //CPP_STALIN_INCLUDE_TYPETRAITS_H_
